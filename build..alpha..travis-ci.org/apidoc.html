<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/yarnpkg/yarn#readme"

    >yarnpkg (v0.15.1)</a>
</h1>
<h4><p align="center">   <a href="https://yarnpkg.com/">     <img alt="Yarn" src="https://github.com/yarnpkg/assets/blob/master/yarn-kitten-full.png?raw=true" width="546">   </a> </p></h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg">module yarnpkg</a><ol>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>config</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>constants</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>errors</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_compatibility</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_constraint_resolver</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_fetcher</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_hoister</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_install_scripts</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_linker</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_reference</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_request</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.</span>package_resolver</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.config">module yarnpkg.config</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.config.default">
            function <span class="apidocSignatureSpan">yarnpkg.config.</span>default
            <span class="apidocSignatureSpan">(reporter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.constants">module yarnpkg.constants</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.constants.getModuleCacheDirectory">
            function <span class="apidocSignatureSpan">yarnpkg.constants.</span>getModuleCacheDirectory
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.constants.getPathKey">
            function <span class="apidocSignatureSpan">yarnpkg.constants.</span>getPathKey
            <span class="apidocSignatureSpan">(platform, env)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yarnpkg.constants.</span>CHILD_CONCURRENCY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yarnpkg.constants.</span>LOCKFILE_VERSION</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yarnpkg.constants.</span>NETWORK_CONCURRENCY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">number <span class="apidocSignatureSpan">yarnpkg.constants.</span>SINGLE_INSTANCE_PORT</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.constants.</span>DEPENDENCY_TYPES</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">yarnpkg.constants.</span>REQUIRED_PACKAGE_KEYS</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>CLEAN_FILENAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>ENV_PATH_KEY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>GITHUB_REPO</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>GITHUB_USER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>GLOBAL_MODULE_DIRECTORY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>INTEGRITY_FILENAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>LINK_REGISTRY_DIRECTORY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>LOCKFILE_FILENAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>METADATA_FILENAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>MODULE_CACHE_DIRECTORY</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>SELF_UPDATE_DOWNLOAD_FOLDER</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>SINGLE_INSTANCE_FILENAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>TARBALL_FILENAME</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.constants.</span>YARN_REGISTRY</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.errors">module yarnpkg.errors</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.errors.MessageError">
            function <span class="apidocSignatureSpan">yarnpkg.errors.</span>MessageError
            <span class="apidocSignatureSpan">(msg, code)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.errors.SecurityError">
            function <span class="apidocSignatureSpan">yarnpkg.errors.</span>SecurityError
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.errors.SpawnError">
            function <span class="apidocSignatureSpan">yarnpkg.errors.</span>SpawnError
            <span class="apidocSignatureSpan">{{signature}}</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_compatibility">module yarnpkg.package_compatibility</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_compatibility.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_compatibility.</span>default
            <span class="apidocSignatureSpan">(config, resolver)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_compatibility.testEngine">
            function <span class="apidocSignatureSpan">yarnpkg.package_compatibility.</span>testEngine
            <span class="apidocSignatureSpan">(name, range, versions, looseSemver)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_constraint_resolver">module yarnpkg.package_constraint_resolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_constraint_resolver.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_constraint_resolver.</span>default
            <span class="apidocSignatureSpan">(config, reporter)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_fetcher">module yarnpkg.package_fetcher</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_fetcher.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_fetcher.</span>default
            <span class="apidocSignatureSpan">(config, resolver)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_hoister">module yarnpkg.package_hoister</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_hoister.HoistManifest">
            function <span class="apidocSignatureSpan">yarnpkg.package_hoister.</span>HoistManifest
            <span class="apidocSignatureSpan">(key, parts, pkg, loc)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_hoister.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_hoister.</span>default
            <span class="apidocSignatureSpan">(config, resolver, ignoreOptional)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_install_scripts">module yarnpkg.package_install_scripts</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_install_scripts.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_install_scripts.</span>default
            <span class="apidocSignatureSpan">(config, resolver, force)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_linker">module yarnpkg.package_linker</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_linker.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_linker.</span>default
            <span class="apidocSignatureSpan">(config, resolver, ignoreOptional)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_linker.linkBin">
            function <span class="apidocSignatureSpan">yarnpkg.package_linker.</span>linkBin
            <span class="apidocSignatureSpan">(_x, _x2)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_reference">module yarnpkg.package_reference</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_reference.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_reference.</span>default
            <span class="apidocSignatureSpan">(request, info, remote)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.package_reference.</span>ENVIRONMENT_IGNORE</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.package_reference.</span>REMOVED_ANCESTOR</span>

        </li>

        <li>

            <span class="apidocSignatureSpan">string <span class="apidocSignatureSpan">yarnpkg.package_reference.</span>USED</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_request">module yarnpkg.package_request</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_request.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_request.</span>default
            <span class="apidocSignatureSpan">(req, resolver)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.yarnpkg.package_resolver">module yarnpkg.package_resolver</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.yarnpkg.package_resolver.default">
            function <span class="apidocSignatureSpan">yarnpkg.package_resolver.</span>default
            <span class="apidocSignatureSpan">(config, lockfile)</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg" id="apidoc.module.yarnpkg">module yarnpkg</a></h1>

























</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.config" id="apidoc.module.yarnpkg.config">module yarnpkg.config</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.config.default" id="apidoc.element.yarnpkg.config.default">
        function <span class="apidocSignatureSpan">yarnpkg.config.</span>default
        <span class="apidocSignatureSpan">(reporter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class Config {
  constructor(reporter) {
    this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).default(this, reporter);
    this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
    this.reporter = reporter;
    this._init({});
  }

  //


  //


  //


  //


  //


  //


  //


  //


  //


  //


  //


  //


  //


  //


<span class="apidocCodeCommentSpan">  /**
   * Execute a promise produced by factory if it doesn&#x27;t exist in our cache with
   * the associated key.
   */
</span>
  getCache(key, factory) {
    const cached = this.cache[key];
    if (cached) {
      return cached;
    }

    return this.cache[key] = factory().catch(err =&#x3e; {
      this.cache[key] = null;
      throw err;
    });
  }

  /**
   * Get a config option from our yarn config.
   */

  getOption(key) {
    return this.registries.yarn.getOption(key);
  }

  /**
   * Reduce a list of versions to a single one based on an input range.
   */

  resolveConstraints(versions, range) {
    return this.constraintResolver.reduce(versions, range);
  }

  /**
   * Initialise config. Fetch registry options, find package roots.
   */

  init() {
    var _this = this;

    let opts = arguments.length &#x3e; 0 &#x26;&#x26; arguments[0] !== undefined ? arguments[0] : {};
    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      _this._init(opts);

      yield (_fs || _load_fs()).mkdirp(_this.globalFolder);
      yield (_fs || _load_fs()).mkdirp(_this.packagesRoot);
      yield (_fs || _load_fs()).mkdirp(_this.tempFolder);

      yield (_fs || _load_fs()).mkdirp(_this.linkFolder);
      _this.linkedModules = yield (_fs || _load_fs()).readdir(_this.linkFolder);

      for (const key of Object.keys((_index2 || _load_index2()).registries)) {
        const Registry = (_index2 || _load_index2()).registries[key];

        // instantiate registry
        const registry = new Registry(_this.cwd, _this.registries, _this.requestManager);
        yield registry.init();

        _this.registries[key] = registry;
        _this.registryFolders.push(registry.folder);
        _this.rootModuleFolders.push(path.join(_this.cwd, registry.folder));
      }

      _this.requestManager.setOptions({
        userAgent: String(_this.getOption(&#x27;user-agent&#x27;)),
        httpProxy: String(_this.getOption(&#x27;proxy&#x27;) || &#x27;&#x27;),
        httpsProxy: String(_this.getOption(&#x27;https-proxy&#x27;) || &#x27;&#x27;)
      });
    })();
  }

  _init(opts) {
    this.rootModuleFolders = [];
    this.registryFolders = [];
    this.linkedModules = [];

    this.registries = (0, (_map || _load_map()).default)();
    this.cache = (0, (_map || _load_map()).default)();
    this.cwd = opts.cwd || this.cwd || process.cwd();

    this.looseSemver = opts.looseSemver == undefined ? true : opts.looseSemver;

    this.preferOffline = !!opts.preferOffline;
    this.modulesFolder = opts.modulesFolder;
    this.globalFolder = opts.globalFolder || (_constants || _load_constants()).GLOBAL_MODULE_DIRECTORY;
    this.packagesRoot = opts.packagesRoot || (_constants || _load_constants()).MODULE_CACHE_DIRECTORY;
    this.linkFolder = opts.linkFolder || (_constants || _load_constants()).LINK_REGISTRY_DIRECTORY;
    this.tempFolder = opts.tempFolder || path.join(this.packagesRoot, &#x27;.tmp&#x27;);
    this.offline = !!opts.offline;

    this.requestManager.setOptions({
      offline: !!opts.offline &#x26;&#x26; !opts.preferOffline,
      captureHar: !!opts.captureHar
    });

    if (this.modulesFolder) {
      this.rootModuleFolders.push(this.modulesFolder);
    }
  }

  /**
   * Generate an absolute module path.
   */

  generateHardModulePath(pkg, ignoreLocation) {
    invariant(this.packagesRoot, &#x27;No package root&#x27;);
    invariant(pkg, &#x27;Undefined package&#x27;);
    invariant(pkg.name, &#x27;No name field in package&#x27;);
    invariant(pkg.uid, &#x27;No uid field in package&#x27;);
    if (pkg.location &#x26;&#x26; !ignoreLocation) {
      return pkg.location;
    }

    let name = pkg.name;
    let uid = pkg.uid;
    if (pkg.registry) {
      name = `${ pkg.registry }-${ name }`;
      uid = pkg.version || uid;
    }

    return path. ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.constants" id="apidoc.module.yarnpkg.constants">module yarnpkg.constants</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.constants.getModuleCacheDirectory" id="apidoc.element.yarnpkg.constants.getModuleCacheDirectory">
        function <span class="apidocSignatureSpan">yarnpkg.constants.</span>getModuleCacheDirectory
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getModuleCacheDirectory() {
  // use %LOCALAPPDATA%/Yarn on Windows
  if (process.platform === &#x27;win32&#x27; &#x26;&#x26; process.env.LOCALAPPDATA) {
    return path.join(process.env.LOCALAPPDATA, &#x27;Yarn&#x27;);
  }

  // otherwise use ~/.yarn
  return path.join(userHome, &#x27;.yarn-cache&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yarnpkg.constants.getPathKey" id="apidoc.element.yarnpkg.constants.getPathKey">
        function <span class="apidocSignatureSpan">yarnpkg.constants.</span>getPathKey
        <span class="apidocSignatureSpan">(platform, env)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function getPathKey(platform, env) {
  let pathKey = &#x27;PATH&#x27;;

  // windows calls it&#x27;s path &#x22;Path&#x22; usually, but this is not guaranteed.
  if (platform === &#x27;win32&#x27;) {
    pathKey = &#x27;Path&#x27;;

    for (const key in env) {
      if (key.toLowerCase() === &#x27;path&#x27;) {
        pathKey = key;
      }
    }
  }

  return pathKey;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>










































</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.errors" id="apidoc.module.yarnpkg.errors">module yarnpkg.errors</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.errors.MessageError" id="apidoc.element.yarnpkg.errors.MessageError">
        function <span class="apidocSignatureSpan">yarnpkg.errors.</span>MessageError
        <span class="apidocSignatureSpan">(msg, code)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class MessageError extends Error {
  constructor(msg, code) {
    super(msg);
    this.code = code;
  }

}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
      } else if (ignore.indexOf(name) &#x3c; 0) {
        this.reporter.warn(`${ human }: ${ this.reporter.lang(&#x27;invalidEngine&#x27;, name) }`);
      }
    }
  }

  if (didError) {
    throw new (_errors || _load_errors()).<span class="apidocCodeKeywordSpan">MessageError</span>(reporter.lang(&#x27;foundIncompatible
&#x27;));
  }
}

init() {
  const infos = this.resolver.getManifests();
  for (const info of infos) {
    this.check(info);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yarnpkg.errors.SecurityError" id="apidoc.element.yarnpkg.errors.SecurityError">
        function <span class="apidocSignatureSpan">yarnpkg.errors.</span>SecurityError
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SecurityError extends Error {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yarnpkg.errors.SpawnError" id="apidoc.element.yarnpkg.errors.SpawnError">
        function <span class="apidocSignatureSpan">yarnpkg.errors.</span>SpawnError
        <span class="apidocSignatureSpan">{{signature}}</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class SpawnError extends Error {}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_compatibility" id="apidoc.module.yarnpkg.package_compatibility">module yarnpkg.package_compatibility</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_compatibility.default" id="apidoc.element.yarnpkg.package_compatibility.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_compatibility.</span>default
        <span class="apidocSignatureSpan">(config, resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageCompatibility {
  constructor(config, resolver) {
    this.reporter = config.reporter;
    this.resolver = resolver;
    this.config = config;
  }

  static isValidArch(archs) {
    return isValid(archs, process.arch);
  }

  static isValidPlatform(platforms) {
    return isValid(platforms, process.platform);
  }

  check(info) {
    let didIgnore = false;
    let didError = false;
    const reporter = this.reporter;
    const human = `${ info.name }@${ info.version }`;

    const pushError = msg =&#x3e; {
      const ref = info._reference;
      invariant(ref, &#x27;expected package reference&#x27;);

      if (ref.optional) {
        ref.addVisibility((_packageReference || _load_packageReference()).ENVIRONMENT_IGNORE);

        reporter.warn(`${ human }: ${ msg }`);
        if (!didIgnore) {
          reporter.info(reporter.lang(&#x27;optionalCompatibilityExcluded&#x27;, human));
          didIgnore = true;
        }
      } else {
        reporter.error(`${ human }: ${ msg }`);
        didError = true;
      }
    };

    if (Array.isArray(info.os)) {
      if (!PackageCompatibility.isValidPlatform(info.os)) {
        pushError(this.reporter.lang(&#x27;incompatibleOS&#x27;, process.platform));
      }
    }

    if (Array.isArray(info.cpu)) {
      if (!PackageCompatibility.isValidArch(info.cpu)) {
        pushError(this.reporter.lang(&#x27;incompatibleCPU&#x27;, process.arch));
      }
    }

    if (!this.config.ignoreEngines &#x26;&#x26; typeof info.engines === &#x27;object&#x27;) {
      for (const entry of (0, (_misc || _load_misc()).entries)(info.engines)) {
        let name = entry[0];
        const range = entry[1];

        if (aliases[name]) {
          name = aliases[name];
        }

        if (VERSIONS[name]) {
          if (!testEngine(name, range, VERSIONS, this.config.looseSemver)) {
            pushError(this.reporter.lang(&#x27;incompatibleEngine&#x27;, name, range));
          }
        } else if (ignore.indexOf(name) &#x3c; 0) {
          this.reporter.warn(`${ human }: ${ this.reporter.lang(&#x27;invalidEngine&#x27;, name) }`);
        }
      }
    }

    if (didError) {
      throw new (_errors || _load_errors()).MessageError(reporter.lang(&#x27;foundIncompatible&#x27;));
    }
  }

  init() {
    const infos = this.resolver.getManifests();
    for (const info of infos) {
      this.check(info);
    }
    return Promise.resolve();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yarnpkg.package_compatibility.testEngine" id="apidoc.element.yarnpkg.package_compatibility.testEngine">
        function <span class="apidocSignatureSpan">yarnpkg.package_compatibility.</span>testEngine
        <span class="apidocSignatureSpan">(name, range, versions, looseSemver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function testEngine(name, range, versions, looseSemver) {
  const actual = versions[name];
  if (!actual) {
    return false;
  }

  if (!semver.valid(actual, looseSemver)) {
    return false;
  }

  if (semver.satisfies(actual, range, looseSemver)) {
    return true;
  }

  if (name === &#x27;node&#x27; &#x26;&#x26; semver.gt(actual, &#x27;1.0.0&#x27;, looseSemver)) {
    // WARNING: this is a massive hack and is super gross but necessary for compatibility
    // some modules have the `engines.node` field set to a caret version below semver major v1
    // eg. ^0.12.0. this is problematic as we enforce engines checks and node is now on version &#x3e;=1
    // to allow this pattern we transform the node version to fake ones in the minor range 10-13
    const major = semver.major(actual, looseSemver);
    const fakes = [`0.10.${ major }`, `0.11.${ major }`, `0.12.${ major }`, `0.13.${ major }`];
    for (const actualFake of fakes) {
      if (semver.satisfies(actualFake, range, looseSemver)) {
        return true;
      }
    }
  }

  // incompatible version
  return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_constraint_resolver" id="apidoc.module.yarnpkg.package_constraint_resolver">module yarnpkg.package_constraint_resolver</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_constraint_resolver.default" id="apidoc.element.yarnpkg.package_constraint_resolver.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_constraint_resolver.</span>default
        <span class="apidocSignatureSpan">(config, reporter)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageConstraintResolver {
  constructor(config, reporter) {
    this.reporter = reporter;
    this.config = config;
  }

  reduce(versions, range) {
    return Promise.resolve(semver.maxSatisfying(versions, range, this.config.looseSemver));
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_fetcher" id="apidoc.module.yarnpkg.package_fetcher">module yarnpkg.package_fetcher</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_fetcher.default" id="apidoc.element.yarnpkg.package_fetcher.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_fetcher.</span>default
        <span class="apidocSignatureSpan">(config, resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageFetcher {
  constructor(config, resolver) {
    this.reporter = config.reporter;
    this.resolver = resolver;
    this.config = config;
  }

  fetchCache(dest, fetcher) {
    var _this = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      var _ref = yield _this.config.readPackageMetadata(dest);

      const hash = _ref.hash;
      const pkg = _ref.package;

      return {
        package: pkg,
        resolved: yield fetcher.getResolvedFromCached(hash),
        hash,
        dest
      };
    })();
  }

  fetch(ref) {
    var _this2 = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      const dest = _this2.config.generateHardModulePath(ref);

      const remote = ref.remote;
      const Fetcher = (_index || _load_index())[remote.type];
      if (!Fetcher) {
        throw new Error(`Unknown fetcher for ${ remote.type }`);
      }

      const fetcher = new Fetcher(dest, remote, _this2.config);

      if (yield _this2.config.isValidModuleDest(dest)) {
        return _this2.fetchCache(dest, fetcher);
      }

      // remove as the module may be invalid
      yield (_fs || _load_fs()).unlink(dest);

      try {
        return yield fetcher.fetch();
      } catch (err) {
        try {
          yield (_fs || _load_fs()).unlink(dest);
        } catch (err2) {
          // what do?
        }
        throw err;
      }
    })();
  }

  maybeFetch(ref) {
    var _this3 = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      try {
        return yield _this3.fetch(ref);
      } catch (err) {
        if (ref.optional) {
          _this3.reporter.error(err.message);
          return null;
        } else {
          throw err;
        }
      }
    })();
  }

  init() {
    var _this4 = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      const pkgs = _this4.resolver.getPackageReferences();
      const tick = _this4.reporter.progress(pkgs.length);

      yield (_promise || _load_promise()).queue(pkgs, (() =&#x3e; {
        var _ref2 = (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* (ref) {
          const res = yield _this4.maybeFetch(ref);
          let newPkg;

          if (res) {
            newPkg = res.package;

            // update with new remote
            ref.remote.hash = res.hash;
            if (res.resolved) {
              ref.remote.resolved = res.resolved;
            }
          }

          if (newPkg) {
            // update with fresh manifest
            yield _this4.resolver.updateManifest(ref, newPkg);
          }

          if (tick) {
            tick(ref.name);
          }
        });

        return function (_x) {
          return _ref2.apply(this, arguments);
        };
      })());
    })();
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_hoister" id="apidoc.module.yarnpkg.package_hoister">module yarnpkg.package_hoister</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_hoister.HoistManifest" id="apidoc.element.yarnpkg.package_hoister.HoistManifest">
        function <span class="apidocSignatureSpan">yarnpkg.package_hoister.</span>HoistManifest
        <span class="apidocSignatureSpan">(key, parts, pkg, loc)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class HoistManifest {
  constructor(key, parts, pkg, loc) {
    this.loc = loc;
    this.pkg = pkg;

    this.key = key;
    this.parts = parts;
    this.originalKey = key;
    this.previousKeys = [];

    this.history = [];
    this.addHistory(`Start position = ${ key }`);
  }

  addHistory(msg) {
    this.history.push(`${ ++historyCounter }: ${ msg }`);
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yarnpkg.package_hoister.default" id="apidoc.element.yarnpkg.package_hoister.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_hoister.</span>default
        <span class="apidocSignatureSpan">(config, resolver, ignoreOptional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageHoister {
  constructor(config, resolver, ignoreOptional) {
    this.ignoreOptional = ignoreOptional;
    this.resolver = resolver;
    this.config = config;

    this.taintedKeys = new Map();
    this.levelQueue = [];
    this.tree = new Map();
  }

<span class="apidocCodeCommentSpan">  /**
   * Taint this key and prevent any modules from being hoisted to it.
   */
</span>
  taintKey(key, info) {
    const existingTaint = this.taintedKeys.get(key);
    if (existingTaint &#x26;&#x26; existingTaint.loc !== info.loc) {
      return false;
    } else {
      this.taintedKeys.set(key, info);
      return true;
    }
  }

  /**
   * Implode an array of ancestry parts into a key.
   */

  implodeKey(parts) {
    return parts.join(&#x27;#&#x27;);
  }

  /**
   * Seed the hoister with patterns taken from the included resolver.
   */

  seed(patterns) {
    for (const pattern of this.resolver.dedupePatterns(patterns)) {
      this._seed(pattern);
    }

    while (true) {
      let queue = this.levelQueue;
      if (!queue.length) {
        return;
      }

      this.levelQueue = [];

      // sort queue to get determinism between runs
      queue = queue.sort((_ref, _ref2) =&#x3e; {
        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 1);

        let aPattern = _ref4[0];

        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 1);

        let bPattern = _ref3[0];

        return (0, (_misc || _load_misc()).sortAlpha)(aPattern, bPattern);
      });

      //
      const infos = [];
      for (const _ref5 of queue) {
        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);

        const pattern = _ref6[0];
        const parents = _ref6[1];

        const info = this._seed(pattern, parents);
        if (info) {
          infos.push(info);
        }
      }

      //
      for (const info of infos) {
        this.hoist(info);
      }
    }
  }

  /**
   * Seed the hoister with a specific pattern.
   */

  _seed(pattern, parent) {
    let parentParts = [];

    if (parent) {
      if (!this.tree.get(parent.key)) {
        return null;
      }
      parentParts = parent.parts;
    }

    //
    const pkg = this.resolver.getStrictResolvedPattern(pattern);
    const ref = pkg._reference;
    invariant(ref, &#x27;expected reference&#x27;);

    //
    const loc = this.config.generateHardModulePath(ref);
    const parts = parentParts.concat(pkg.name);
    const key = this.implodeKey(parts);
    const info = new HoistManifest(key, parts, pkg, loc);

    //
    this.tree.set(key, info);
    this.taintKey(key, info);

    //
    for (const depPattern of ref.dependencies) {
      this.levelQueue.push([depPattern, info]);
    }

    return info;
  }

  /**
   * Find the highest position we can hoist this module to.
   */

  getNewParts(key, info, parts) {
    let stepUp = false;

    const fullKey = this.implodeKey(parts);
    const stack = []; // stack of removed parts
    const name = parts.pop();

    //
    for (let i = parts.length - 1; i &#x3e;= 0; i--) {
      const checkParts = parts.slice(0, i).concat(name);
      const checkKey = this.implodeKey(checkParts);
      info.addHistory(`Looked at ${ checkKey } for a match`);

      const existing = this.tree.get(checkKey);
      if (existing) {
        if (existing.loc === info.loc) {
          existing.addHistory(`Deduped ${ fullKey } to this item`);
          return { parts: checkParts, duplicate: true };
        } else {
          // everything above will be shadowed and this is a conflict
          info.addHistory(`Found a collision at ${ checkKey }`);
          break;
        }
      }

      const existingTaint = this.taintedKeys.get(checkKey);
      if (existingTaint &#x26;&#x26; existingTaint.loc !== info.loc) {
        info.addHistory(`Broken by ${ checkKey }`);
        break;
      }
    }

    // remove redundant parts that wont collide
    while (parts.length) {
      const checkParts = parts.concat(name);
      const checkKey = this.implodeKey(checkParts);

      //
      const existing = this.tree.get(checkKey);
      if (existing) {
        stepUp = true;
        b ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_install_scripts" id="apidoc.module.yarnpkg.package_install_scripts">module yarnpkg.package_install_scripts</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_install_scripts.default" id="apidoc.element.yarnpkg.package_install_scripts.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_install_scripts.</span>default
        <span class="apidocSignatureSpan">(config, resolver, force)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageInstallScripts {
  constructor(config, resolver, force) {
    this.installed = 0;
    this.resolver = resolver;
    this.reporter = config.reporter;
    this.config = config;
    this.force = force;
  }

  getInstallCommands(pkg) {
    const scripts = pkg.scripts;
    if (scripts) {
      const cmds = [];
      for (const stage of INSTALL_STAGES) {
        const cmd = scripts[stage];
        if (cmd) {
          cmds.push([stage, cmd]);
        }
      }
      return cmds;
    } else {
      return [];
    }
  }

  walk(loc) {
    var _this = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      const files = yield (_fs || _load_fs()).walk(loc, null, new Set(_this.config.registryFolders));
      const mtimes = new Map();
      for (const file of files) {
        mtimes.set(file.relative, file.mtime);
      }
      return mtimes;
    })();
  }

  wrapCopyBuildArtifacts(loc, pkg, spinner, factory) {
    var _this2 = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      const beforeFiles = yield _this2.walk(loc);
      const res = yield factory();
      const afterFiles = yield _this2.walk(loc);

      // work out what files have been created/modified
      const buildArtifacts = [];
      for (const _ref of afterFiles) {
        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);

        const file = _ref2[0];
        const mtime = _ref2[1];

        if (!beforeFiles.has(file) || beforeFiles.get(file) !== mtime) {
          buildArtifacts.push(file);
        }
      }

      // install script may have removed files, remove them from the cache too
      const removedFiles = [];
      for (const _ref3 of beforeFiles) {
        var _ref4 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref3, 1);

        const file = _ref4[0];

        if (!afterFiles.has(file)) {
          removedFiles.push(file);
        }
      }

      if (!removedFiles.length &#x26;&#x26; !buildArtifacts.length) {
        // nothing else to do here since we have no build side effects
        return res;
      }

      // if the process is killed while copying over build artifacts then we&#x27;ll leave
      // the cache in a bad state. remove the metadata file and add it back once we&#x27;ve
      // done our copies to ensure cache integrity.
      const cachedLoc = _this2.config.generateHardModulePath(pkg._reference, true);
      const cachedMetadataLoc = path.join(cachedLoc, (_constants || _load_constants()).METADATA_FILENAME);
      const cachedMetadata = yield (_fs || _load_fs()).readFile(cachedMetadataLoc);
      yield (_fs || _load_fs()).unlink(cachedMetadataLoc);

      // remove files that install script removed
      if (removedFiles.length) {
        for (const file of removedFiles) {
          yield (_fs || _load_fs()).unlink(path.join(cachedLoc, file));
        }
      }

      // copy over build artifacts to cache directory
      if (buildArtifacts.length) {
        const copyRequests = [];
        for (const file of buildArtifacts) {
          copyRequests.push({
            src: path.join(loc, file),
            dest: path.join(cachedLoc, file),
            onDone() {
              spinner.tick(`Cached build artifact ${ file }`);
            }
          });
        }
        yield (_fs || _load_fs()).copyBulk(copyRequests, {
          possibleExtraneous: false
        });
        yield (_fs || _load_fs()).writeFile(cachedMetadataLoc, cachedMetadata);
      }

      return res;
    })();
  }

  install(cmds, pkg, spinner) {
    var _this3 = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      const loc = _this3.config.generateHardModulePath(pkg._reference);
      try {
        yield _this3.wrapCopyBuildArtifacts(loc, pkg, spinner, (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function
* () {
          for (const _ref6 of cmds) {
            var _ref7 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref6, 2);

            const stage = _ref7[0]; ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_linker" id="apidoc.module.yarnpkg.package_linker">module yarnpkg.package_linker</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_linker.default" id="apidoc.element.yarnpkg.package_linker.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_linker.</span>default
        <span class="apidocSignatureSpan">(config, resolver, ignoreOptional)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageLinker {
  constructor(config, resolver, ignoreOptional) {
    this.ignoreOptional = ignoreOptional;
    this.resolver = resolver;
    this.reporter = config.reporter;
    this.config = config;
  }

  linkSelfDependencies(pkg, pkgLoc, targetBinLoc) {
    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      targetBinLoc = yield (_fs || _load_fs()).realpath(targetBinLoc);
      pkgLoc = yield (_fs || _load_fs()).realpath(pkgLoc);
      for (const _ref2 of (0, (_misc || _load_misc()).entries)(pkg.bin)) {
        var _ref3 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref2, 2);

        const scriptName = _ref3[0];
        const scriptCmd = _ref3[1];

        const dest = path.join(targetBinLoc, scriptName);
        const src = path.join(pkgLoc, scriptCmd);
        if (!(yield (_fs || _load_fs()).exists(src))) {
          // TODO maybe throw an error
          continue;
        }
        yield linkBin(src, dest);
      }
    })();
  }

  linkBinDependencies(pkg, dir) {
    var _this = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      const deps = [];

      const ref = pkg._reference;
      invariant(ref, &#x27;Package reference is missing&#x27;);

      const remote = pkg._remote;
      invariant(remote, &#x27;Package remote is missing&#x27;);

      // link up `bin scripts` in `dependencies`
      for (const pattern of ref.dependencies) {
        const dep = _this.resolver.getStrictResolvedPattern(pattern);
        if (dep.bin &#x26;&#x26; Object.keys(dep.bin).length) {
          deps.push({ dep, loc: _this.config.generateHardModulePath(dep._reference) });
        }
      }

      // link up the `bin` scripts in bundled dependencies
      if (pkg.bundleDependencies) {
        for (const depName of pkg.bundleDependencies) {
          const loc = path.join(_this.config.generateHardModulePath(ref), _this.config.getFolder(pkg), depName);

          const dep = yield _this.config.readManifest(loc, remote.registry);

          if (dep.bin &#x26;&#x26; Object.keys(dep.bin).length) {
            deps.push({ dep, loc });
          }
        }
      }

      // no deps to link
      if (!deps.length) {
        return;
      }

      // ensure our .bin file we&#x27;re writing these to exists
      const binLoc = path.join(dir, &#x27;.bin&#x27;);
      yield (_fs || _load_fs()).mkdirp(binLoc);

      // write the executables
      for (const _ref4 of deps) {
        const dep = _ref4.dep;
        const loc = _ref4.loc;

        yield _this.linkSelfDependencies(dep, loc, binLoc);
      }
    })();
  }

  getFlatHoistedTree(patterns) {
    const hoister = new (_packageHoister || _load_packageHoister()).default(this.config, this.resolver, this.ignoreOptional);
    hoister.seed(patterns);
    return Promise.resolve(hoister.init());
  }

  copyModules(patterns) {
    var _this2 = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      let flatTree = yield _this2.getFlatHoistedTree(patterns);

      // sorted tree makes file creation and copying not to interfere with each other
      flatTree = flatTree.sort(function (dep1, dep2) {
        return dep1[0].localeCompare(dep2[0]);
      });

      //
      const queue = new Map();
      for (const _ref5 of flatTree) {
        var _ref6 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref5, 2);

        const dest = _ref6[0];
        var _ref6$ = _ref6[1];
        const pkg = _ref6$.pkg;
        const src = _ref6$.loc;

        const ref = pkg._reference;
        invariant(ref, &#x27;expected package reference&#x27;);
        ref.setLocation(dest);

        queue.set(dest, {
          src,
          dest,
          onFresh() {
            if (ref) {
              ref.setFresh(true);
            }
          }
        });
      }

      // register root packages as being possibly extraneous
      const possibleExtraneous = new Set();
      for (const folder of _this2.config.registryFolders) {
        const loc = path.join(_this2.config.cwd, folder);

        if (yield (_fs || _load_fs()).exists ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.yarnpkg.package_linker.linkBin" id="apidoc.element.yarnpkg.package_linker.linkBin">
        function <span class="apidocSignatureSpan">yarnpkg.package_linker.</span>linkBin
        <span class="apidocSignatureSpan">(_x, _x2)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function linkBin(_x, _x2) {
  return _ref.apply(this, arguments);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_reference" id="apidoc.module.yarnpkg.package_reference">module yarnpkg.package_reference</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_reference.default" id="apidoc.element.yarnpkg.package_reference.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_reference.</span>default
        <span class="apidocSignatureSpan">(request, info, remote)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageReference {
  constructor(request, info, remote) {
    this.resolver = request.resolver;
    this.lockfile = request.lockfile;
    this.requests = [];
    this.config = request.config;

    this.registry = remote.registry;
    this.version = info.version;
    this.name = info.name;
    this.uid = info._uid;

    this.remote = remote;

    this.dependencies = [];

    this.permissions = {};
    this.patterns = [];
    this.optional = null;
    this.visibility = { [ENVIRONMENT_IGNORE]: 0, [REMOVED_ANCESTOR]: 0, [USED]: 0 };
    this.root = false;
    this.ignore = false;
    this.fresh = false;
    this.location = null;

    this.addRequest(request);
  }

  setFresh(fresh) {
    this.fresh = fresh;
  }

  setLocation(loc) {
    return this.location = loc;
  }

  addRequest(request) {
    this.requests.push(request);

    if (!request.parentRequest) {
      this.root = true;
    }
  }

  prune() {
    for (const selfPattern of this.patterns) {
      // remove ourselves from the resolver
      this.resolver.removePattern(selfPattern);
    }
  }

  addDependencies(deps) {
    this.dependencies = this.dependencies.concat(deps);
  }

  setPermission(key, val) {
    this.permissions[key] = val;
  }

  hasPermission(key) {
    if (key in this.permissions) {
      return this.permissions[key];
    } else {
      return false;
    }
  }

  addPattern(pattern, manifest) {
    this.resolver.addPattern(pattern, manifest);

    this.patterns.push(pattern);

    const shrunk = this.lockfile.getLocked(pattern);
    if (shrunk &#x26;&#x26; shrunk.permissions) {
      for (const _ref of (0, (_misc || _load_misc()).entries)(shrunk.permissions)) {
        var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);

        const key = _ref2[0];
        const perm = _ref2[1];

        this.setPermission(key, perm);
      }
    }
  }

  addOptional(optional) {
    if (this.optional == null) {
      // optional is uninitialised
      this.optional = optional;
    } else if (!optional) {
      // otherwise, ignore all subsequent optional assignments and only accept ones making
      // this not optional
      this.optional = false;
    }
  }

  calculateVisibility() {
    let nowIgnore = false;
    const stack = this.visibility;

    // if we don&#x27;t use this module then mark it as ignored
    if (stack[USED] === 0) {
      nowIgnore = true;
    }

    // if we have removed as many ancestors as it&#x27;s used then it&#x27;s out of the tree
    if (stack[REMOVED_ANCESTOR] &#x3e;= stack[USED]) {
      nowIgnore = true;
    }

    this.ignore = nowIgnore;
  }

  addVisibility(action) {
    let ancestry = arguments.length &#x3e; 1 &#x26;&#x26; arguments[1] !== undefined ? arguments[1] : new Set();

    this.visibility[action]++;
    this.calculateVisibility();

    if (ancestry.has(this)) {
      return;
    }
    ancestry.add(this);

    // go through and update all transitive dependencies to be ignored
    for (const pattern of this.dependencies) {
      const pkg = this.resolver.getResolvedPattern(pattern);
      if (!pkg) {
        continue;
      }

      const ref = pkg._reference;
      invariant(ref, &#x27;expected package reference&#x27;);
      ref.addVisibility(action, ancestry);
    }
  }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>








</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_request" id="apidoc.module.yarnpkg.package_request">module yarnpkg.package_request</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_request.default" id="apidoc.element.yarnpkg.package_request.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_request.</span>default
        <span class="apidocSignatureSpan">(req, resolver)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageRequest {
  constructor(req, resolver) {
    this.parentRequest = req.parentRequest;
    this.visibility = req.visibility;
    this.lockfile = resolver.lockfile;
    this.registry = req.registry;
    this.reporter = resolver.reporter;
    this.resolver = resolver;
    this.optional = req.optional;
    this.pattern = req.pattern;
    this.config = resolver.config;

    resolver.usedRegistries.add(req.registry);
  }

  static getExoticResolver(pattern) {
    // TODO make this type more refined
    for (const _ref of (0, (_misc || _load_misc()).entries)((_index || _load_index()).exotics)) {
      var _ref2 = (0, (_slicedToArray2 || _load_slicedToArray()).default)(_ref, 2);

      const Resolver = _ref2[1];

      if (Resolver.isVersion(pattern)) {
        return Resolver;
      }
    }
    return null;
  }

  getParentNames() {
    const chain = [];

    let request = this.parentRequest;
    while (request) {
      const info = this.resolver.getStrictResolvedPattern(request.pattern);
      chain.unshift(info.name);

      request = request.parentRequest;
    }

    return chain;
  }

  getLocked(remoteType) {
    // always prioritise root lockfile
    const shrunk = this.lockfile.getLocked(this.pattern);

    if (shrunk) {
      const resolvedParts = (_version || _load_version()).explodeHashedUrl(shrunk.resolved);

      return {
        name: shrunk.name,
        version: shrunk.version,
        _uid: shrunk.uid,
        _remote: {
          resolved: shrunk.resolved,
          type: remoteType,
          reference: resolvedParts.url,
          hash: resolvedParts.hash,
          registry: shrunk.registry
        },
        optionalDependencies: shrunk.optionalDependencies,
        dependencies: shrunk.dependencies
      };
    } else {
      return null;
    }
  }

<span class="apidocCodeCommentSpan">  /**
   * If the input pattern matches a registry one then attempt to find it on the registry.
   * Otherwise fork off to an exotic resolver if one matches.
   */
</span>
  findVersionOnRegistry(pattern) {
    var _this = this;

    return (0, (_asyncToGenerator2 || _load_asyncToGenerator()).default)(function* () {
      var _PackageRequest$norma = PackageRequest.normalizePattern(pattern);

      const range = _PackageRequest$norma.range;
      const name = _PackageRequest$norma.name;


      const exoticResolver = PackageRequest.getExoticResolver(range);
      if (exoticResolver) {
        let data = yield _this.findExoticVersionInfo(exoticResolver, range);

        // clone data as we&#x27;re manipulating it in place and this could be resolved multiple
        // times
        data = Object.assign({}, data);

        // this is so the returned package response uses the overridden name. ie. if the
        // package&#x27;s actual name is `bar`, but it&#x27;s been specified in the manifest like:
        //   &#x22;foo&#x22;: &#x22;http://foo.com/bar.tar.gz&#x22;
        // then we use the foo name
        data.name = name;

        return data;
      }

      const Resolver = _this.getRegistryResolver();
      const resolver = new Resolver(_this, name, range);
      return resolver.resolve();
    })();
  }

  /**
   * Get the registry resolver associated with this package request.
   */

  getRegistryResolver() {
    const Resolver = (_index2 || _load_index2()).registries[this.registry];
    if (Resolver) {
      return Resolver;
    } else {
      throw new Error(`Unknown registry resolver ${ this.registry }`);
    }
  }

  /**
   * Explode and normalize a pattern into it&#x27;s name and range.
   */

  static normalizePattern(pattern) {
    let hasVersion = false;
    let range = &#x27;latest&#x27;;
    let name = pattern;

    // if we&#x27;re a scope then remove the @ and add it back later
    let isScoped = false;
    if (name[0] === &#x27;@&#x27;) {
      isScoped = true;
      name = name.slice(1);
    }

    // take first part as the name
    const parts = name.split(&#x27;@&#x27;);
    if (parts.length &#x3e; 1) {
      name = parts.shift();
      range = parts.join(&#x27;@&#x27;);

      if (range) {
        hasVersion = true;
      } else {
        range = &#x27;*&#x27;;
      }
    }

    // add back @ scope suffix
    if (isScoped) { ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.yarnpkg.package_resolver" id="apidoc.module.yarnpkg.package_resolver">module yarnpkg.package_resolver</a></h1>


    <h2>
        <a href="#apidoc.element.yarnpkg.package_resolver.default" id="apidoc.element.yarnpkg.package_resolver.default">
        function <span class="apidocSignatureSpan">yarnpkg.package_resolver.</span>default
        <span class="apidocSignatureSpan">(config, lockfile)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">class PackageResolver {
  constructor(config, lockfile) {
    this.patternsByPackage = (0, (_map || _load_map()).default)();
    this.fetchingPatterns = (0, (_map || _load_map()).default)();
    this.fetchingQueue = new (_blockingQueue || _load_blockingQueue()).default(&#x27;resolver fetching&#x27;);
    this.newPatterns = [];
    this.patterns = (0, (_map || _load_map()).default)();
    this.usedRegistries = new Set();
    this.flat = false;

    this.reporter = config.reporter;
    this.lockfile = lockfile;
    this.config = config;
  }

  // whether the dependency graph will be flattened


  // list of registries that have been used in this resolution


  // activity monitor


  // patterns we&#x27;ve already resolved or are in the process of resolving


  // new patterns that didn&#x27;t exist in the lockfile


  // TODO


  // these are patterns that the package resolver was seeded with. these are required in
  // order to resolve top level peerDependencies


  // manages and throttles json api http requests


  // list of patterns associated with a package


  // lockfile instance which we can use to retrieve version info


  // a map of dependency patterns to packages


  // reporter instance, abstracts out display logic


  // environment specific config methods and options


<span class="apidocCodeCommentSpan">  /**
   * TODO description
   */
</span>
  isNewPattern(pattern) {
    return this.newPatterns.indexOf(pattern) &#x3e;= 0;
  }

  /**
   * TODO description
   */

  updateManifest(ref, newPkg) {
    // inherit fields
    const oldPkg = this.patterns[ref.patterns[0]];
    newPkg._reference = ref;
    newPkg._remote = ref.remote;
    newPkg.name = oldPkg.name;

    // update patterns
    for (const pattern of ref.patterns) {
      this.patterns[pattern] = newPkg;
    }

    return Promise.resolve();
  }

  /**
   * Given a list of patterns, dedupe them to a list of unique patterns.
   */

  dedupePatterns(patterns) {
    const deduped = [];
    const seen = new Set();

    for (const pattern of patterns) {
      const info = this.getResolvedPattern(pattern);
      if (seen.has(info)) {
        continue;
      }

      seen.add(info);
      deduped.push(pattern);
    }

    return deduped;
  }

  /**
   * Get a list of all manifests by topological order.
   */

  getTopologicalManifests(seedPatterns) {
    const pkgs = new Set();
    const skip = new Set();

    const add = seedPatterns =&#x3e; {
      for (const pattern of seedPatterns) {
        const pkg = this.getStrictResolvedPattern(pattern);
        if (skip.has(pkg)) {
          continue;
        }

        const ref = pkg._reference;
        invariant(ref, &#x27;expected reference&#x27;);
        skip.add(pkg);
        add(ref.dependencies);
        pkgs.add(pkg);
      }
    };

    add(seedPatterns);

    return pkgs;
  }

  /**
   * Get a list of all manifests by level sort order.
   */

  getLevelOrderManifests(seedPatterns) {
    const pkgs = new Set();
    const skip = new Set();

    const add = seedPatterns =&#x3e; {
      const refs = [];

      for (const pattern of seedPatterns) {
        const pkg = this.getStrictResolvedPattern(pattern);
        if (skip.has(pkg)) {
          continue;
        }

        const ref = pkg._reference;
        invariant(ref, &#x27;expected reference&#x27;);

        refs.push(ref);
        skip.add(pkg);
        pkgs.add(pkg);
      }

      for (const ref of refs) {
        add(ref.dependencies);
      }
    };

    add(seedPatterns);

    return pkgs;
  }

  /**
   * Get a list of all package names in the depenency graph.
   */

  getAllDependencyNamesByLevelOrder(seedPatterns) {
    const names = new Set();
    for (const _ref of this.getLevelOrderManifests(seedPatterns)) {
      const name = _ref.name;

      names.add(name);
    }
    return names;
  }

  /**
   * Retrieve all the package info stored for this package name.
   */

  getAllInfoForPackageName(name) {
    const infos = [];
    const seen = new Set();

    for (const pattern of this.patternsByPackage[name]) {
      const info = this.patterns[pattern];
      if (seen.has(info)) {
        continue;
      }

      seen.add(info);
      inf ...</pre></li>
    <li>example usage<pre class="apidocCodePre">...
const invariant = require(&#x27;invariant&#x27;);

const path = require(&#x27;path&#x27;);
const url = require(&#x27;url&#x27;);

class Config {
constructor(reporter) {
  this.constraintResolver = new (_packageConstraintResolver || _load_packageConstraintResolver()).<span class="apidocCodeKeywordSpan
">default</span>(this, reporter);
  this.requestManager = new (_requestManager || _load_requestManager()).default(reporter);
  this.reporter = reporter;
  this._init({});
}

//
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
